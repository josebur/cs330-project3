#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <sstream>

#include "Token.h"

using namespace std;

Token token;

bool program(istream &is);
bool function(istream &is);
bool compound(istream &is);
bool stmtlist(istream &is);
bool stmt(istream &is);

struct Memory
{
    Memory(string nameValue, int startValue, int endValue)
    {
        name = nameValue;
        start = startValue;
        end = endValue;
        size = end - start + 1;
    }

    string name;
    int start;
    int end;
    int size;
};

vector<Memory> variables;
vector<Memory> heap;

bool deleteVariable(string id);
bool malloc(string id, string size);
void PrintVars();
void PrintHeap();
void PrintBlank();

int main(int argc, char *argv[])
{
    string filename;
    int heapSize;

    if (argc == 1) {
        cout << "Enter a filename to use: ";
        cin >> filename;
        cout << "Enter the heap size to use: ";
        cin >> heapSize;
    }
    else if (argc == 3) {
        filename = argv[1];
        stringstream ss(argv[2]);
        ss >> heapSize;
    }
    else {
        cerr << "USAGE: ./heapify <file> <heap size>" << endl;
        return -1;
    }

    ifstream inFile(filename.c_str());
    if (!inFile) {
        cerr << "ERROR: Could not open file:\"" << filename << "\"" <<endl;
        return -1;
    }

    heap.push_back(Memory("heap", 0, heapSize - 1));

    token.Get(inFile);
    if (program(inFile)) {
        cout << "## This is a valid program." << endl;
    }
    else {
        cout << "## This is not a valid program" << endl;
    }
    
    return 0;
}

/* Function program
    Parses string in the language generated by the rule:
    <program> -> <function>
*/
bool program(istream &is)
{
    return function(is);
}

/* Function function
    Parses strings in the language generated by the rule:
    <function> -> LBRACK VOID RBRACK ID LPAREN RPAREN <compound>
*/
bool function(istream &is)
{
    if (token.Type() == LBRACK) {
        token.Get(is);
        if (token.Type() == VOID) {
            token.Get(is);
            if (token.Type() == RBRACK) {
                token.Get(is);
                if (token.Type() == ID) {
                    token.Get(is);
                    if (token.Type() == LPAREN) {
                        token.Get(is);
                        if (token.Type() == RPAREN) {
                            token.Get(is);
                            return compound(is);
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        else {
            return false;
        }
    }
    else {
        return false;
    }
}

/* Function compound
    Parses string in the language generated by the rule:
    <compound> -> BEGIN <stmtlist> END
*/
bool compound(istream &is)
{
    // test for begin token
    if (token.Type() == BEGIN) {
        token.Get(is);
        // get all the valid statements
        if (stmtlist(is)) {
            // test to make sure there is a closing end token
            if (token.Type() == END) {
                token.Get(is);
                return true;
            }
            else {
                return false;
            }
        }
        else {
            return false;
        }
    }
    return false;
}

/* Function stmtlist
    Parses string in the language generated by the rule:
    <stmtlist> -> <stmt> |
               -> <stmt> SEMICOLON <stmtlist>
*/
bool stmtlist(istream &is)
{
    if (stmt(is)) {
        if (token.Type() == SEMICOLON) {
            token.Get(is);
            return stmtlist(is);
        }
    }
    return true;
}

/* Function stmt
    Parses string in the language generated by the rule:
    <stmt> -> ID |
           -> ID LPAREN NUM_INT RPAREN |
           -> ID ASSIGNOP ID LPAREN NUM_INT RPAREN
*/
bool stmt(istream &is)
{
    if (token.Type() == ID) {
        string id = token.Value();
        token.Get(is);
        if (token.Type() == LPAREN) { // delete
            token.Get(is);
            if (token.Type() == ID) {
                string variable = token.Value();
                //cout << variable;
                token.Get(is);
                if (token.Type() == RPAREN) {
                    token.Get(is);
                    deleteVariable(variable);
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        else if (token.Type() == ASSIGNOP) {
            token.Get(is);
            if (token.Type() == ID) {
                token.Get(is);
                if (token.Type() == LPAREN) {
                    token.Get(is);
                    if (token.Type() == NUM_INT) {
                        string size = token.Value();
                        token.Get(is);
                        if (token.Type() == RPAREN) {
                            token.Get(is);
                            malloc(id, size);
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        else {
            if (id == "PrintVars") {
                PrintVars();
            }
            else if (id == "PrintHeap") {
                PrintHeap();
            }
            else if (id == "PrintBlank") {
                PrintBlank();
            }
            return true;
        }
    }
    else {
        return false;
    }
}

bool deleteVariable(string id)
{
    cout << "deleteVariable: " << id << endl;
    return true;
}

bool malloc(string id, string size)
{
    cout << "malloc: " << id << " of size " << size << endl;
    return true;
}

void PrintVars()
{
    cout << "Current list of dynamic variables with allocations:" << endl;
    if (variables.empty()) {
        cout << "   <empty>" << endl;
    }
    else {
        vector<Memory>::iterator it;
        for (it = variables.begin(); it != variables.end(); ++it) {
            cout << (*it).name << "-->[" << (*it).start << " ... " << (*it).end
                 << "] (" << (*it).size << ")" << endl;
        }
    }
    cout << "==== End of variable listing ====" << endl;
}

void PrintHeap()
{
    cout << "Heap freelist is currently:" << endl;
    if (heap.empty()) {
        cout << "   <empty>" << endl;
    }
    else {
        vector<Memory>::iterator it;
        for (it = heap.begin(); it != heap.end(); ++it) {
            cout << (*it).name << "-->[" << (*it).start << " ... " << (*it).end
                 << "] (" << (*it).size << ")" << endl;
        }
    }
    cout << "==== End of variable listing ====" << endl;
}

void PrintBlank()
{
    cout << endl;
}
