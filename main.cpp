#include <iostream>
#include <fstream>
#include <string>

#include "Token.h"

using namespace std;

Token token;

bool program(istream &is);
bool function(istream &is);
bool compound(istream &is);
bool stmtlist(istream &is);
bool stmt(istream &is);

int main(int argc, char *argv[])
{
    string filename;

    if (argc == 1) {
        cout << "Enter a filename to use: ";
        cin >> filename;
    }
    else if (argc == 2) {
        filename = argv[1];
    }
    else {
        cerr << "USAGE: ./beautify <file>" << endl;
        return -1;
    }

    ifstream inFile(filename.c_str());
    if (!inFile) {
        cerr << "ERROR: Could not open file:\"" << filename << "\"" <<endl;
        return -1;
    }

    token.Get(inFile);
    if (program(inFile)) {
        cout << "## This is a valid program." << endl;
        cout << "##### beautified code follows #####" << endl;
        cout << "##### end beautified code #####" << endl;
    }
    else {
        cout << "## This is not a valid program" << endl;
    }
    
    return 0;
}

/* Function program
    Parses string in the language generated by the rule:
    <program> -> <function>
*/
bool program(istream &is)
{
    return true;
}

/* Function function
    Parses strings in the language generated by the rule:
    <function> -> LBRACK VOID RBRACK ID LPAREN RPAREN <compound>
*/
bool function(istream &is)
{
    return true;
}

/* Function compound
    Parses string in the language generated by the rule:
    <compound> -> BEGIN <stmtlist> END
*/
bool compound(istream &is)
{
    // test for begin token
    if (token.Type() == BEGIN) {
        token.Get(is);
        // get all the valid statements
        if (stmtlist(is)) {
            // test to make sure there is a closing end token
            if (token.Type() == END) {
                token.Get(is);
                return true;
            }
            else {
                return false;
            }
        }
        else {
            return false;
        }
    }
    return false;
}

/* Function stmtlist
    Parses string in the language generated by the rule:
    <stmtlist> -> <stmt> |
               -> <stmt> SEMICOLON <stmtlist>
*/
bool stmtlist(istream &is)
{
    if (stmt(is)) {
        if (token.Type() == SEMICOLON) {
            token.Get(is);
            return stmtlist(is);
        }
    }
    return true;
}

/* Function stmt
    Parses string in the language generated by the rule:
    <stmt> -> ID |
           -> ID LPAREN NUM_INT RPAREN |
           -> ID ASSIGNOP ID LPAREN NUM_INT RPAREN
*/
bool stmt(istream &is)
{
    return true;
}
